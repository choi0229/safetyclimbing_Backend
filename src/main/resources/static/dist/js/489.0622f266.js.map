{"version":3,"file":"js/489.0622f266.js","mappings":"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","sources":["webpack://frontend/./src/views/MountainDetailView2.vue","webpack://frontend/./src/views/MountainDetailView2.vue?0c74","webpack://frontend/./node_modules/chart.js/auto/auto.js"],"sourcesContent":["<template>\r\n  <div id=\"app\">\r\n    <HeaderView style=\"z-index: 4;width: 1920px;\"></HeaderView>\r\n\r\n    <div class=\"d-flex\">    \r\n      <div class=\"row\" style=\"margin: 0px; padding: 0px;\">\r\n        <div id=\"map\" style=\"width: 100%; height: 680px; margin: 0px;\"></div>\r\n        <canvas id=\"elevationChart\" width=\"400px\" height=\"100px\"></canvas>\r\n      </div>\r\n    </div>\r\n\r\n  </div>\r\n</template>\r\n\r\n<script setup>\r\nimport { onMounted, ref } from 'vue';\r\nimport Chart from 'chart.js/auto';\r\nimport axios from \"axios\";\r\n\r\n/* global kakao */\r\nconst map = ref(null);\r\nconst routeCoordinates = ref([]);\r\nlet chartInstance = null;\r\nconst currentMarker = ref(null);\r\n\r\nonMounted(() => {\r\n  initializeMap();\r\n  fetchWeatherData(37.66433293993584, 127.01160029114365);\r\n});\r\n\r\n// 내 위치를 가져오는 함수\r\n\r\n\r\nfunction initializeMap() {\r\n  // Kakao Maps API 스크립트 로드\r\n  const script = document.createElement('script');\r\n  script.onload = () => kakao.maps.load(() => {\r\n    map.value = new kakao.maps.Map(document.getElementById('map'), {\r\n      center: new kakao.maps.LatLng(37.66433293993584, 127.01160029114365),\r\n      level: 5\r\n    });\r\n\r\n    loadGeoJSONFromServer('/data/인왕산ele copy.geojson');\r\n\r\n    // 마커 추가 JSON 데이터 로드\r\n    loadMarkers(\"/data/헬기장spot.geojson\" , '/images/helipad.png');\r\n    loadMarkers(\"/data/벤치spot.geojson\", '/images/bench.png'); // 마커 데이터 경로\r\n    loadMarkers(\"/data/2023산악사고_인왕산.geojson\", '/images/danger.png'); // 마커 데이터 경로\r\n  });\r\n  script.src = 'https://dapi.kakao.com/v2/maps/sdk.js?appkey=333bda7da18df138fb4d9b3e5cf351c4&autoload=false';\r\n  document.head.appendChild(script);\r\n}\r\n\r\nasync function loadGeoJSONFromServer(url) {\r\n  try {\r\n    const response = await fetch(url);\r\n    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\r\n    const geojsonData = await response.json();\r\n    processGeoJSON(geojsonData);\r\n  } catch (error) {\r\n    console.error('GeoJSON 파일 로드 중 에러 발생:', error);\r\n  }\r\n}\r\n\r\n// JSON 데이터를 사용하여 마커 추가\r\nasync function loadMarkers(url, imageSrc) {\r\n  try {\r\n    const response = await fetch(url); // JSON 파일에서 마커 정보를 가져오기\r\n    if (!response.ok) {\r\n      throw new Error(`HTTP error! status: ${response.status}`);\r\n    }\r\n    const markerData = await response.json();\r\n    console.log(`${url} 마커 데이터 로드 성공:`, markerData);\r\n\r\n    // MNTN_NM이 \"북한산\", \"도봉산\", \"수리산\" 인 항목만 필터링\r\n    const filteredMarkers = markerData.features.filter((feature) => {\r\n      mountainName.value = feature.properties.MNTN_NM;\r\n\r\n      return mountainName.value == '북한산_백운대';\r\n    });\r\n\r\n    const imageSize = new kakao.maps.Size(35,45);\r\n    const imageOpation = { offset: new kakao.maps.Point(12, 35)};\r\n    const markerImage = new kakao.maps.MarkerImage(imageSrc, imageSize, imageOpation);\r\n\r\n    // GeoJSON 데이터의 features 배열에서 마커 추가\r\n    filteredMarkers.forEach((spot) => {\r\n      const lat = spot.geometry.coordinates[1]; // 위도\r\n      const lng = spot.geometry.coordinates[0]; // 경도\r\n      const markerPosition = new kakao.maps.LatLng(lat, lng); // 마커 좌표\r\n\r\n      // 마커 생성\r\n      const marker = new kakao.maps.Marker({\r\n        position: markerPosition, // 마커 위치\r\n        map: map.value, // 마커를 표시할 지도 객체\r\n        title: spot.properties.MNTN_NM, // 마커 제목\r\n        image: markerImage,\r\n      });\r\n\r\n      // 마커에 대한 정보창 추가\r\n      const infowindow = new kakao.maps.InfoWindow({\r\n        content: `<div style=\"padding:5px;\">${spot.properties.MNTN_NM}<br>${spot.properties.SAFE_SPOT2}</div>`, // 정보창 내용\r\n      });\r\n\r\n      // 마커에 마우스오버 이벤트 등록\r\n      kakao.maps.event.addListener(marker, 'mouseover', () => infowindow.open(map.value, marker));\r\n      kakao.maps.event.addListener(marker, 'mouseout', () => infowindow.close());\r\n    });\r\n  } catch (error) {\r\n    console.error(`${url} 파일 로드 중 에러 발생:`, error);\r\n  }\r\n}\r\n\r\n// 좌표 그룹화 함수\r\nfunction groupCoordinates(coordinates, groupSize) {\r\n  const groups = [];\r\n  for (let i = 0; i < coordinates.length; i += groupSize) {\r\n    groups.push(coordinates.slice(i, i + groupSize));\r\n  }\r\n  return groups;\r\n}\r\n\r\n\r\n// 경사도에 따른 색상 결정 함수\r\nfunction getColorBySlope(slope) {\r\n  if (slope > 30) return '#FF4500'; // 급경사 (빨강)\r\n  if (slope < -15) return '#1E90FF'; // 급한 내리막 (파랑)\r\n  return '#32CD32'; // 평지에 가까움 (초록)\r\n}\r\n\r\n\r\n\r\n// processGeoJSON 함수 수정\r\nfunction processGeoJSON(geojsonData) {\r\n  let allCoordinates = [];\r\n\r\n  geojsonData.features.forEach((feature) => {\r\n    if (feature.properties.PMNTN_NM && feature.properties.PMNTN_NM.includes('')) {\r\n      let coordinates = [];\r\n\r\n      if (feature.geometry.type === 'MultiLineString') {\r\n        feature.geometry.coordinates.forEach(line => {\r\n          coordinates = coordinates.concat(line.map((coord) => ({\r\n            lng: coord[0],\r\n            lat: coord[1],\r\n            elevation: feature.properties.DN || 0\r\n          })));\r\n        });\r\n      } else if (feature.geometry.type === 'LineString') {\r\n        coordinates = feature.geometry.coordinates.map((coord) => ({\r\n          lng: coord[0],\r\n          lat: coord[1],\r\n          elevation: feature.properties.DN || 0\r\n        }));\r\n      }\r\n      routeCoordinates.value = allCoordinates;  // 경로 좌표를 할당\r\n      allCoordinates = allCoordinates.concat(coordinates);\r\n    }\r\n  });\r\n  \r\n  if (allCoordinates.length > 0) {\r\n    const groupedCoordinates = groupCoordinates(allCoordinates, 7); // 5개씩 그룹화\r\n    addRouteLayer(groupedCoordinates);\r\n    drawElevationChart(allCoordinates);\r\n  } else {\r\n    console.log('유효한 구간 데이터가 없습니다.');\r\n  }\r\n}\r\n\r\n\r\n// addRouteLayer 함수 수정\r\nfunction addRouteLayer(groupedCoordinates) {\r\n  const baseCoordinates = groupedCoordinates.flat(); // 경로를 평탄하게 만듦\r\n  drawBaseRoute(baseCoordinates); // 기본 녹색 경로 그리기\r\n\r\n  groupedCoordinates.forEach((group) => {\r\n    if (group.length > 1) {\r\n      const startPoint = group[0];\r\n      const endPoint = group[group.length - 1];\r\n      const slope = calculateSlope(startPoint, endPoint);\r\n      const color = getColorBySlope(slope);\r\n\r\n      const linePath = group.map(coord => new kakao.maps.LatLng(coord.lat, coord.lng));\r\n\r\n      const polyline = new kakao.maps.Polyline({\r\n        path: linePath,\r\n        strokeWeight: 5,\r\n        strokeColor: color,\r\n        strokeOpacity: 0.8,\r\n        strokeStyle: 'solid'\r\n      });\r\n\r\n      polyline.setMap(map.value);\r\n    }\r\n  });\r\n\r\n  // 경로에 맞게 지도 중심과 줌 조정\r\n  const bounds = new kakao.maps.LatLngBounds();\r\n  groupedCoordinates.flat().forEach(coord => bounds.extend(new kakao.maps.LatLng(coord.lat, coord.lng)));\r\n  map.value.setBounds(bounds);\r\n}\r\n\r\n// 새로운 함수: 기본 녹색 경로를 그리는 함수\r\nfunction drawBaseRoute(coordinates) {\r\n  const linePath = coordinates.map(coord => new kakao.maps.LatLng(coord.lat, coord.lng));\r\n\r\n  const basePolyline = new kakao.maps.Polyline({\r\n    path: linePath,\r\n    strokeWeight: 5,\r\n    strokeColor: '#32CD32', // 기본 경로 색상 (녹색)\r\n    strokeOpacity: 1, // 기본 경로는 약간 투명하게 설정\r\n    strokeStyle: 'solid'\r\n  });\r\n\r\n  basePolyline.setMap(map.value);\r\n}\r\n\r\nfunction calculateDistance(index, coord, coordinates) {\r\n  if (index === 0) return 0; // 첫 번째 좌표의 거리는 0\r\n\r\n  const prevCoord = coordinates[index - 1];\r\n\r\n  const R = 6371; // 지구 반지름 (km)\r\n  const dLat = deg2rad(coord[1] - prevCoord[1]);\r\n  const dLng = deg2rad(coord[0] - prevCoord[0]);\r\n\r\n  const a =\r\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\r\n    Math.cos(deg2rad(prevCoord[1])) * Math.cos(deg2rad(coord[1])) *\r\n    Math.sin(dLng / 2) * Math.sin(dLng / 2);\r\n\r\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n  return R * c; // 거리 반환\r\n}\r\n\r\nfunction calculateHaversineDistance(coord1, coord2) {\r\n  const R = 6371e3; // 지구 반지름 (미터 단위)\r\n  const lat1 = deg2rad(coord1.lat);\r\n  const lat2 = deg2rad(coord2.lat);\r\n  const deltaLat = deg2rad(coord2.lat - coord1.lat);\r\n  const deltaLon = deg2rad(coord2.lng - coord1.lng);\r\n\r\n  const a =\r\n    Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +\r\n    Math.cos(lat1) * Math.cos(lat2) *\r\n    Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);\r\n\r\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n\r\n  // 두 지점 간의 거리 반환 (미터 단위)\r\n  return R * c;\r\n}\r\n\r\nfunction calculateSlope(start, end) {\r\n  // 하버사인 공식을 사용하여 두 지점 간의 수평 거리 (지구 곡률 반영)\r\n  const horizontalDistance = calculateHaversineDistance(\r\n    { lat: start.lat, lng: start.lng },\r\n    { lat: end.lat, lng: end.lng }\r\n  );\r\n\r\n  // 고도 차이 계산\r\n  const elevationChange = end.elevation - start.elevation;\r\n\r\n  // 피타고라스 정리를 사용해 두 지점 간의 대각선 거리 계산\r\n  const diagonalDistance = Math.sqrt(\r\n    Math.pow(horizontalDistance, 2) + Math.pow(elevationChange, 2)\r\n  );\r\n\r\n  // 수평 거리가 너무 짧으면 경사도 계산을 무시하고 기본 경사도 0으로 설정\r\n  if (horizontalDistance < 1) { // 예시: 수평 거리가 10m 미만일 경우\r\n    return 0; // 경사도 0으로 간주\r\n  }\r\n\r\n  // 경사도 = 고도 차이 / 대각선 거리 * 100\r\n  return (elevationChange / diagonalDistance) * 100;\r\n}\r\n\r\nfunction deg2rad(deg) {\r\n  return deg * (Math.PI / 180);\r\n}\r\n\r\nfunction drawElevationChart(data) {\r\n  const ctx = document.getElementById('elevationChart').getContext('2d');\r\n\r\n  // 누적 거리 계산 (기존의 총 거리를 계산)\r\n  const distances = calculateCumulativeDistances(data.map(point => [point.lng, point.lat]));\r\n  const totalDistance = distances[distances.length - 1]; // 총 거리\r\n  const scaleFactor = 645 / totalDistance; // 645m에 맞추기 위한 스케일링 비율\r\n\r\n  // 각 누적 거리를 스케일링\r\n  const scaledDistances = distances.map(distance => distance * scaleFactor);\r\n  const elevations = data.map(point => point.elevation); // y축: 고도\r\n\r\n  if (chartInstance) {\r\n    chartInstance.destroy(); // 기존 차트 제거\r\n    chartInstance = null;\r\n  }\r\n\r\n  chartInstance = new Chart(ctx, {\r\n    type: 'line',\r\n    data: {\r\n      labels: scaledDistances, // x축: 스케일링된 누적 거리\r\n      datasets: [\r\n        {\r\n          label: '고도 (m)',\r\n          data: elevations,  // y축: 고도\r\n          borderColor: 'rgba(75, 192, 192, 1)',\r\n          borderWidth: 2,\r\n          fill: false,\r\n        },\r\n      ],\r\n    },\r\n    options: {\r\n      scales: {\r\n        x: {\r\n          title: {\r\n            display: true,\r\n            text: '거리 (m)', // x축 제목 (미터 단위로 표시)\r\n          },\r\n          ticks: {\r\n            autoSkip: true, // 자동으로 레이블을 생략함\r\n            maxTicksLimit: 10, // 최대 레이블 개수를 10개로 제한\r\n            maxRotation: 0, // 레이블을 비스듬히 하지 않음\r\n            minRotation: 0, // 레이블을 수평으로 유지\r\n            callback: function(value) {\r\n              return value.toFixed(2) + ' m'; // 원하는 형식으로 레이블 포맷\r\n            }\r\n          }\r\n        },\r\n        y: {\r\n          title: {\r\n            display: true,\r\n            text: '고도 (m)', // y축 제목\r\n          },\r\n        },\r\n      },\r\n      interaction: {\r\n        mode: 'index',\r\n        intersect: false,\r\n      },\r\n      plugins: {\r\n        tooltip: {\r\n          enabled:false,\r\n        },\r\n      },\r\n      onClick: (event, elements) => {\r\n        if (elements.length > 0) {\r\n          const index = elements[0].index;\r\n          highlightRouteOnMap(index); // 클릭 시 지도에서 경로 강조\r\n        }\r\n      },\r\n      onHover: (event, elements) => {\r\n        if (elements.length > 0) {\r\n          const index = elements[0].index;\r\n          highlightRouteOnMap(index); // 마우스 오버 시 경로 강조\r\n        }\r\n      },\r\n    },\r\n  });\r\n}\r\n\r\nfunction calculateCumulativeDistances(coordinates) {\r\n  let cumulativeDistances = [];\r\n  let totalDistance = 0;\r\n\r\n  for (let i = 0; i < coordinates.length; i++) {\r\n    if (i > 0) {\r\n      totalDistance += calculateDistance(i, coordinates[i], coordinates);\r\n    }\r\n    cumulativeDistances.push(totalDistance);\r\n  }\r\n\r\n  return cumulativeDistances;\r\n}\r\n\r\n\r\nfunction highlightRouteOnMap(index) {\r\n  if (index >= 0 && index < routeCoordinates.value.length) {\r\n    const point = routeCoordinates.value[index];  // 해당 인덱스의 좌표를 가져옴\r\n\r\n    console.log(\"마우스 오버 인덱스:\", index);\r\n    console.log(\"해당 좌표:\", point);\r\n\r\n    // 기존 마커 제거\r\n    if (currentMarker.value) {\r\n      currentMarker.value.setMap(null);\r\n    }\r\n\r\n    // 새로운 마커 추가\r\n    currentMarker.value = new kakao.maps.Marker({\r\n      position: new kakao.maps.LatLng(point.lat, point.lng),  // 마커 위치 설정\r\n    });\r\n\r\n    currentMarker.value.setMap(map.value);  // 지도에 마커 표시\r\n\r\n    // 해당 경로로 지도 이동\r\n    map.value.panTo(new kakao.maps.LatLng(point.lat, point.lng));\r\n  } else {\r\n    console.error(`Invalid index: ${index}`);\r\n  }\r\n}\r\n\r\n\r\n\r\n// 날씨\r\nconst mountainName = ref(\"\");\r\nconst dailyWeather = ref([]);\r\nconst sunriseTimes = ref([]);\r\nconst sunsetTimes = ref([]);\r\n\r\n\r\n// 날씨 정보 조회\r\nconst fetchWeatherData = async (latitude, longitude) => {\r\n  try {\r\n    const apiKey = \"5c48577c775896e979e7bcc3b225b730\";\r\n    const response = await axios.get(\r\n      `https://api.openweathermap.org/data/2.5/forecast?lat=${latitude}&lon=${longitude}&appid=${apiKey}`\r\n    );\r\n\r\n    console.log(response.data); // 응답 확인용 콘솔 로그\r\n\r\n    const groupedByDay = {};\r\n    response.data.list.forEach(item => {\r\n      const date = item.dt_txt.split(\" \")[0];\r\n      if (!groupedByDay[date]) groupedByDay[date] = [];\r\n      groupedByDay[date].push(item);\r\n    });\r\n\r\n    const selectedWeather = [];\r\n    Object.keys(groupedByDay).forEach(date => {\r\n      const { currentTemp, minTemp, maxTemp } = calculateMinMaxTemp(groupedByDay[date]);\r\n      const daySummary = {\r\n        date,\r\n        currentTemp,\r\n        minTemp,\r\n        maxTemp,\r\n        ...groupedByDay[date][0],\r\n      };\r\n      selectedWeather.push(daySummary);\r\n    });\r\n\r\n    dailyWeather.value = selectedWeather;\r\n\r\n    const sunriseSunsetPromises = dailyWeather.value.map(day =>\r\n      axios.get(\r\n        `https://api.sunrise-sunset.org/json?lat=${latitude}&lng=${longitude}&date=${day.date}&formatted=0`\r\n      )\r\n    );\r\n\r\n    const sunriseSunsetResults = await Promise.all(sunriseSunsetPromises);\r\n    sunriseTimes.value = sunriseSunsetResults.map(result => formatTime(result.data.results.sunrise));\r\n    sunsetTimes.value = sunriseSunsetResults.map(result => formatTime(result.data.results.sunset));\r\n\r\n  } catch (error) {\r\n    console.error(\"Error fetching weather data:\", error);\r\n  }\r\n};\r\n\r\n\r\nconst calculateMinMaxTemp = (dayData) => {\r\n  const temps = dayData.map(item => item.main.temp);\r\n  const currentTemp = dayData[0].main.temp;\r\n  const minTemp = Math.min(...temps);\r\n  const maxTemp = Math.max(...temps);\r\n  return { currentTemp, minTemp, maxTemp };\r\n};\r\n\r\n// 시간 포맷 변환 함수\r\nconst formatTime = (time) => {\r\n  const date = new Date(time);\r\n  return date.toLocaleTimeString(\"ko-KR\", { hour: \"2-digit\", minute: \"2-digit\", timeZone: \"Asia/Seoul\" });\r\n};\r\n\r\n</script>\r\n\r\n<style scoped>\r\n#map {\r\n  height: 600px;\r\n  width: 100%;\r\n  position: relative; \r\n}\r\n\r\ncanvas {\r\n  height: 200px;\r\n  width: 100%;\r\n}\r\n.weather-forecast {\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  max-width: 100%;\r\n}\r\n\r\n.forecast-header {\r\n  text-align: center;\r\n  margin-bottom: 20px;\r\n}\r\n\r\n.forecast-grid {\r\n  display: grid;\r\n  grid-template-columns: repeat(6, 1fr); /* 5일 날씨에 맞게 5개의 칸으로 */\r\n  gap: 5px;\r\n  width: 100%; /* 부모 요소의 너비를 꽉 채움 */\r\n}\r\n\r\n.forecast-item {\r\n  text-align: center;\r\n  padding: 5px;\r\n  border: 1px solid #ccc;\r\n  border-radius: 10px;\r\n  background-color: #f7f7f7; /* 배경 색상 추가로 가독성 향상 */\r\n  box-shadow: 0px 2px 10px rgba(0, 0, 0, 0.1); /* 가벼운 그림자 추가 */\r\n}\r\n\r\n.forecast-date {\r\n  font-weight: bold;\r\n  margin-bottom: 10px; /* 날짜와 온도 사이 간격 추가 */\r\n}\r\n\r\n.forecast-info {\r\n  margin-top: 10px;\r\n}\r\n\r\n.current-temperature {\r\n  font-size: 30px;\r\n  font-weight: bold;\r\n  color: #333; /* 텍스트 색상을 진하게 */\r\n}\r\n\r\n.weather-icon {\r\n  font-size: 30px; /* 날씨 이모티콘 크기를 키움 */\r\n  margin-top: 10px;\r\n}\r\n\r\n.description {\r\n  font-size: 16px;\r\n  color: #555;\r\n  margin-top: 5px;\r\n}\r\n\r\n.temperature-range {\r\n  margin-top: 5px;\r\n}\r\n\r\n.min-temp, .max-temp {\r\n  font-size: 16px;\r\n  color: #555;\r\n}\r\n\r\n.sun-info {\r\n  margin-top: 10px;\r\n}\r\n\r\n.icon-small {\r\n  width: 16px;\r\n  height: 16px; \r\n  vertical-align: middle;\r\n  margin-right: 5px; /* 아이콘과 텍스트 간의 간격 추가 */\r\n}\r\n\r\n.rain-info {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  gap: 8px;\r\n}\r\n\r\n.rain-icon {\r\n  width: 20px;\r\n  height: 30px;\r\n  background-color: rgba(173, 216, 230, 0.5);\r\n  border-radius: 50%;\r\n  position: relative;\r\n  overflow: hidden;\r\n}\r\n\r\n.rain-icon::before {\r\n  content: '';\r\n  position: absolute;\r\n  bottom: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: var(--rain-level, 0);\r\n  background-color: rgba(30, 144, 255, 1);\r\n}\r\n\r\n.rain-chance {\r\n  font-size: 14px;\r\n  font-weight: bold;\r\n}\r\n\r\n</style>\r\n","import script from \"./MountainDetailView2.vue?vue&type=script&setup=true&lang=js\"\nexport * from \"./MountainDetailView2.vue?vue&type=script&setup=true&lang=js\"\n\nimport \"./MountainDetailView2.vue?vue&type=style&index=0&id=6976e944&scoped=true&lang=css\"\n\nimport exportComponent from \"../../node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['__scopeId',\"data-v-6976e944\"]])\n\nexport default __exports__","import {Chart, registerables} from '../dist/chart.js';\n\nChart.register(...registerables);\n\nexport * from '../dist/chart.js';\nexport default Chart;\n"],"names":["map","ref","routeCoordinates","chartInstance","currentMarker","initializeMap","script","document","createElement","onload","kakao","maps","load","value","Map","getElementById","center","LatLng","level","loadGeoJSONFromServer","loadMarkers","src","head","appendChild","async","url","response","fetch","ok","Error","status","geojsonData","json","processGeoJSON","error","console","imageSrc","markerData","log","filteredMarkers","features","filter","feature","mountainName","properties","MNTN_NM","imageSize","Size","imageOpation","offset","Point","markerImage","MarkerImage","forEach","spot","lat","geometry","coordinates","lng","markerPosition","marker","Marker","position","title","image","infowindow","InfoWindow","content","SAFE_SPOT2","event","addListener","open","close","groupCoordinates","groupSize","groups","i","length","push","slice","getColorBySlope","slope","allCoordinates","PMNTN_NM","includes","type","line","concat","coord","elevation","DN","groupedCoordinates","addRouteLayer","drawElevationChart","baseCoordinates","flat","drawBaseRoute","group","startPoint","endPoint","calculateSlope","color","linePath","polyline","Polyline","path","strokeWeight","strokeColor","strokeOpacity","strokeStyle","setMap","bounds","LatLngBounds","extend","setBounds","basePolyline","calculateDistance","index","prevCoord","R","dLat","deg2rad","dLng","a","Math","sin","cos","c","atan2","sqrt","calculateHaversineDistance","coord1","coord2","lat1","lat2","deltaLat","deltaLon","start","end","horizontalDistance","elevationChange","diagonalDistance","pow","deg","PI","data","ctx","getContext","distances","calculateCumulativeDistances","point","totalDistance","scaleFactor","scaledDistances","distance","elevations","destroy","Chart","labels","datasets","label","borderColor","borderWidth","fill","options","scales","x","display","text","ticks","autoSkip","maxTicksLimit","maxRotation","minRotation","callback","toFixed","y","interaction","mode","intersect","plugins","tooltip","enabled","onClick","elements","highlightRouteOnMap","onHover","cumulativeDistances","panTo","onMounted","fetchWeatherData","dailyWeather","sunriseTimes","sunsetTimes","latitude","longitude","apiKey","axios","get","groupedByDay","list","item","date","dt_txt","split","selectedWeather","Object","keys","currentTemp","minTemp","maxTemp","calculateMinMaxTemp","daySummary","sunriseSunsetPromises","day","sunriseSunsetResults","Promise","all","result","formatTime","results","sunrise","sunset","dayData","temps","main","temp","min","max","time","Date","toLocaleTimeString","hour","minute","timeZone","__exports__","register","registerables"],"sourceRoot":""}